function between(t, e, n) {
  return e <= t && t <= n;
}
var rtd = (t) => (180 * t) / Math.PI;
class Vector1 {
  constructor(t) {
    this.x = t;
  }
  add(t) {
    return new Vector1(this.x + t.x);
  }
  sub(t) {
    return new Vector1(this.x - t.x);
  }
  mul(t) {
    return new Vector1(this.x * t.x);
  }
  div(t) {
    return new Vector1(this.x / t.x);
  }
  sqrt() {
    return new Vector1(Math.sqrt(this.x));
  }
  pow(t) {
    return this.ipow(t.x);
  }
  ipow(t) {
    return new Vector1(Math.pow(this.x, t));
  }
  abs() {
    return new Vector1(Math.abs(this.x));
  }
  signFlip() {
    return new Vector1(-1 * this.x);
  }
  neg() {
    return new Vector1(-1 * Math.abs(this.x));
  }
}
class Vector2 {
  constructor(t, e) {
    (this.x = t), (this.y = e);
  }
  add(t) {
    return new Vector2(this.x + t.x, this.y + t.y);
  }
  sub(t) {
    return new Vector2(this.x - t.x, this.y - t.y);
  }
  mul(t) {
    return new Vector2(this.x * t.x, this.y * t.y);
  }
  div(t) {
    return new Vector2(this.x / t.x, this.y / t.y);
  }
  pow(t) {
    return this.ipow(t.x);
  }
  ipow(t) {
    return new Vector2(Math.pow(this.x, t), Math.pow(this.y, t));
  }
}
const EARTH_ACCEL = new Vector1(9.8),
  AIR_DRAG_COEFF = new Vector1(0.05),
  AIR_RHO = new Vector1(1.225),
  EARTH_SETTINGS = [AIR_RHO, EARTH_ACCEL, AIR_DRAG_COEFF, EARTH_ACCEL];
function radians(t) {
  return (t * Math.PI) / 180;
}
function vu1motion(t, e, n, r) {
  return new Vector1(0.5).mul(t.add(e)).mul(r);
}
function d2motionNoV_t(t, e, n, r) {
  return (
    (v_x = e.x),
    (x = t.x + e.x * r.x),
    (v_y = e.y - n.x * r.x),
    (y = t.y + e.y * r.x - 0.5 * n.x * Math.pow(r.x, 2)),
    [new Vector2(v_x, v_y), new Vector2(x, y), n, r]
  );
}
function terminalVelocity(t, e, n, r, x) {
  return new Vector1(Math.sqrt((2 * t.x * e.x) / (n.x * r.x * x.x)));
}
function projMotion(t, e, n, r, o, s, i, c) {
  return (
    (v_t = terminalVelocity(n, i, r, o, s)),
    (v_x = e.x),
    (x = t.x + e.x * c.x),
    (v_y = e.y - i.x * c.x),
    (y = t.y + e.y * c.x + 0.5 * i.x * Math.pow(c.x, 2)),
    [
      new Vector2(
        Math.abs(v_x) > v_t.x
          ? v_x < 0
            ? -Math.abs(v_t.x)
            : Math.abs(v_t.x)
          : v_x,
        Math.abs(v_y) > v_t.x
          ? v_y < 0
            ? -Math.abs(v_t.x)
            : Math.abs(v_t.x)
          : v_y
      ),
      new Vector2(x, y),
      i,
      c,
    ]
  );
}
function elasticCollision(t, e, n, r, x, o, s) {
  var t = new Vector2(magnitude(t, n), magnitude(e, r)),
    e = n,
    r =
      ((t.x * Math.cos(o.x - s.x) * (x.x - x.y) +
        2 * x.y * e.y * Math.cos(o.y - s.x)) /
        (x.x + x.y)) *
        Math.cos(s.x) +
      e.x * Math.sin(o.x - s.x) * Math.cos(s.x + Math.PI / 2),
    n =
      ((t.x * Math.cos(o.x - s.x) * (x.x - x.y) +
        2 * x.y * e.y * Math.cos(o.y - s.x)) /
        (x.x + x.y)) *
        Math.sin(s.x) +
      e.x * Math.sin(o.x - s.x) * Math.sin(s.x + Math.PI / 2),
    i =
      ((t.y * Math.cos(o.y - s.x) * (x.y - x.x) +
        2 * x.x * e.x * Math.cos(o.x - s.x)) /
        (x.y + x.x)) *
        Math.cos(s.x) +
      e.y * Math.sin(o.y - s.x) * Math.cos(s.x + Math.PI / 2),
    t =
      ((t.y * Math.cos(o.y - s.x) * (x.y - x.x) +
        2 * x.x * e.x * Math.cos(o.x - s.x)) /
        (x.y + x.x)) *
        Math.sin(s.x) +
      e.y * Math.sin(o.y - s.x) * Math.sin(s.x + Math.PI / 2);
  return [new Vector2(r, n), new Vector2(i, t)];
}
function didCollide(t, e, n) {
  return (
    (between(t.x, e.x, e.x + n.x) && between(t.y, e.y, e.y + n.x)) ||
    (between(e.x, t.x, t.x + n.x) && between(e.y, t.y, t.y + n.x))
  );
}
function sides(t, e) {
  return new Vector2(e.x - t.x, e.y - t.y);
}
function pythag(t, e) {
  return Math.sqrt(t * t + e * e);
}
function magnitude(t, e) {
  t = sides(t, e);
  return pythag(t.x, t.y);
}
function angleOfCollision(t, e) {
  angle_of_collision = new Vector1(angle(t.x, t.y, e.x, e.y));
}
function angle(t, e, n, r) {
  return Math.atan2(r - e, n - t);
}
const BLANK2 = new Vector2(0, 0);
class sObject {
  constructor(t, e, n, r) {
    (this.m = t),
      (this.s = e),
      (this.dp = n),
      (this.p = n),
      (this.prop = r),
      (this.v = new Vector2(0, 0));
  }
  accelerate(t) {
    this.v = this.v.add(t);
  }
  reset() {
    (this.v = BLANK2), (this.p = this.dp);
  }
  projectileMotion(t) {
    t = projMotion(this.p, this.v, this.m, ...this.prop, t);
    return (this.v = t[0]), (this.p = t[1]), t;
  }
  elasticCollision(t, e) {
    var n,
      r,
      x = this.p,
      o = t.p,
      s = this.v,
      i = t.v,
      c = this.m,
      h = t.m;
    return (
      (x = didCollide(x, o, this.s)
        ? ((h = new Vector2(h.x, c.x)),
          (c = new Vector1(angle(x.x, x.y, o.x, o.y))),
          (n = new Vector1(angle(x.x, x.y, x.x + s.x, x.y + s.y))),
          (r = new Vector1(angle(o.x, o.y, o.x + i.x, o.y + i.y))),
          elasticCollision(x, o, s, i, h, new Vector2(n.x, r.x), c))
        : [s, i]),
      this.projectileMotion(e),
      t.projectileMotion(e),
      x
    );
  }
}
var physics = {
  name: "physics",
  version: "v1.0.0",
  requires: [],
  optionalRequires: [],
  optFuncs: {},
  description: "Adds support for basic projectile physics to mattex.",
  funcs: {
    p_obj(t, e, n, r, x, o = EARTH_SETTINGS) {
      return new sObject(
        new Vector1(x),
        new Vector2(n, r),
        new Vector2(t, e),
        o
      );
    },
    p_rect(t, e, n) {
      this.rect(t.p.x, -t.p.y, t.s.x, t.s.y, e, n);
    },
  },
};
